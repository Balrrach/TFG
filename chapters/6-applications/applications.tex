\documentclass[..]{subfiles}


\begin{document}

\chapter{Applications}\label{chap:applications}

This chapter has two main sections. The first one is comprised by the formal description of the Public Transaction Ledger problem as well as the description of a solution for such problem. The second one is comprised by the formal description of the General Byzantines problem and two posible three solutions for such problem. All but one of the provided solutions make extensive use of the properties of the protocol proved in Chapter \ref{chap:properties}. This chapter is mainly based on \cite{garay2015bitcoin}, \cite{santoro2006design} and \cite{zhang2013om}.


\section{Public Transaction Ledger}

A ledger $\ell \in \mathcal{L}$ is a sequence of sequences of transactions tx $\in \mathcal{T}$. The blocks content will be sequences of transactions $\langle tx_1, \dots, tx_m \rangle$. Thus, by definition, the chains content $x_\C = \langle x_1, \dots, x_n \rangle$ is a ledger. The \textit{position} of a transaction in a chain is determined by its blocks index along with its sequence index, i.e, a transaction tx has position $(i, j)$ if it is the $j$-th transaction of the $i$-th block.

A transaction relates the state of one or more \textit{accounts} $a_1, a_2, \dots$ etc. An account is an object that encapsulates a state. In order to manage accounts and relations between transactions two functions need to be considered. The following external functions need to be defined by the application that wishes to implement any public transaction ledger:
\begin{itemize}
	\item \texttt{Txgen}$(\cdot)$: A functionality. It needs to provide an answer to the following queries:
	\begin{itemize}
		\item \texttt{GenAccount}: It generates an account $a$.
		\item \texttt{IssueTx}$(\hat{\textrm{tx}})$: It returns a transaction tx given that $\hat{\textrm{tx}}$ is some properly provided string.
	\end{itemize}

	\item $C(\cdot, \cdot)$: a symmetric relation on $\mathcal T$. Returns true when two transactions are conflicting.
\end{itemize}

A ledger is said to be valid if it contains only valid transactions. For the sake of simplicity no more restrictions will be imposed on the ledgers but the results hold for further restricted ledgers. Functionality \texttt{Txgen} is said to be unambiguous if it holds that for all PPT $\mathcal{A}$ produces a transaction $tx'$ such that $C(tx', tx) = 1$ for a $tx$ issued by \texttt{Txgen} is negligible in $\kappa$. I.e, when the adversary doesn't have the possibility to create transaction that are conflicting with the ones generated by \texttt{Txgen} for honest accounts.

For a protocol to implement a robust public transaction ledger it needs to satisfy (i) \textit{Persistence} and (ii) \textit{Liveness}. Persistence property implies that once an honest party reports a transaction ``deep enough'' in its local chain, from that point on, all honest parties will report such transaction at exactly the same position in the ledger. In this sense, Persistence means that all honest parties agree on all transaction and the order at which they took place. Liveness implies that any transaction that comes from \texttt{Txgen}, when provided by the environment to all honest players for a sufficient number of rounds, will eventually be inserted in all parties ledgers.

\begin{definition}[Public Transaction Ledger Problem]
	A protocol $\Pi$ implements a robust public transaction ledger in the $q$-bounded synchronous setting if it organizes the ledger as a hashchain of blocks of transactions and it satisfies:
	\begin{enumerate}[(i)]
		\item Persistence: Parameterized by $k \in \N$, if in a certain round an honest player reports a ledger that contains a transaction tx in a block more than $k$ blocks away from the end of the ledger, then tx will be reported by any honest player in the same position in the ledger, from this round on.
		\item Liveness: Parameterized by $t, k \in \N$, provided that a transaction issued by \texttt{Txgen} is given as input to all honest players continuously for $t$ consecutive rounds, then all honest parties will reports this transaction more than $k$ blocks from the end of the ledger.
	\end{enumerate}
\end{definition}

Related to Persistence, parameter $k$ will be known as the ``depth'' parameter and transactions allocated on the first $k$ blocks of the chain will be called \textit{stable}. The smaller $k$, the sooner transactions become stable, thus, it is desirable for $k$ to be as small as posible. It is important to note that it cannot be demanded for a transaction to be reported as stable the same rounds it is reported to be on the first $k$ blocks of a given chain. This is because the adversary could advance the chain of only a few parties leading to a disagreement that will last until next round takes place.

Related to Liveness, parameter $t$ will be known as the ``wait time'' parameter and $k$ will also be known as the ``depth'' parameter. In this particular model transaction broadcast is handled by the environment $Z$ it is required that the environment $Z$ provides each transaction as input so that the liveness property guarantees its eventual inclusion to the ledger. An alternative definition of the liveness property can be made so that transaction exchange between parties is possible(or even mandatory). It that case, a single honest party receiving the transaction as input would suffice.


\subsection{Nakamoto Solution}

Nakamoto provided a protocol that implements a public transaction ledger. Such protocol will be referred to as $\Pi_{\textrm{PL}}$ and is specified in Table \ref{tab:protocolPL}. In order to prove that such protocol implements a public transaction ledger persistence and liveness properties will be proved.

\begin{centering}
	\begin{table}[H]
	\begin{tabular}{m{0.1\textwidth}<{\centering} m{0.15\textwidth}<{\centering} m{0.665\textwidth}}
		\toprule
		\textbf{Function } & \textbf{Parameters} & \multicolumn{1}{c}{\textbf{Description}}\\
		\toprule
		$V(\cdot)$ & - & $V(\langle x_1, \dots, x_n \rangle)$ is the if and only if sequence $\langle x_1, \dots, x_n \rangle$ is a valid ledger.\\
		\hline
		$R(\cdot)$ & - & $R(\C)$ returns $\langle x_1, \dots, x_n \rangle$.\\
		\hline
		$I(\cdot)$ & - & If the input tape contains (INSERT, $v$), it parses $v$ as a sequence of transactions and retains the largest subsequence $x'$ that is valid with respect to $x_\C$ and whose transactions are not included in $x_\C$.\\
		\bottomrule
	\end{tabular}
		\caption{Protocol $\Pi_{\textrm{PL}}$}
	\label{tab:protocolPL}
	\end{table}
\end{centering}

\begin{lemma}(Persistence)
	Under the Honest Majority Assumption, it holds that $\Pi_{PL}$ described in Table \ref{tab:protocolPL} parameterized with $k = \lceil 2\lambda f \rceil$ satisfies Persistence with probability at least $1 - e^{-\Omega(\epsilon^2 \lambda f)}$.
\end{lemma}
\begin{proof}
	The result follows directly from the Common Prefix property. Consider a typical execution and let $\C_1$ be the local chain of an honest party $P_1$ on round $r_1$. Suppose in round $r_1$ tx is a transaction that belongs to $\C_1^{\lceil k}$. Consider a local chain $\C_2$ belonging to an honest party $P_2$ on round $r_2 \ge r_1$. By the common prefix property, $\C_1 \preceq \C_2$ and the statement follows.
\end{proof}


\begin{lemma}[Liveness]
	Under the Honest Majority Assumption, it holds that $\Pi_{PL}$ described in Table \ref{tab:protocolPL} parameterized with $t = \lceil 4\lambda/(1-\epsilon) \rceil$ rounds and $k = \lceil 2\lambda f \rceil$ satisfies Liveness with probability at least $1 - e^{-\Omega(\epsilon^2 \lambda f)}$.
\end{lemma}
\begin{proof}
	It will be proved that, assuming all honest players receive as input the transaction tx for at least $t$ rounds, then, in a typical execution there exists an honest party with chain $\C$ such that tx is included in $\C^{\lceil k}$. In a typical execution, after $t$ rounds the honest parties chain will be at least $4\lambda / (1-\epsilon) = 2k$ blocks longer. At that exact moment, by the chain quality property, the length-$k$ prefix of any honest parties pruned-$k$ local chain $\C^{\lceil k}$ contains at least one block mined by the honest parties. Such block must contain tx since it is impossible for adversarial $\mathcal{Z}, \mathcal{A}$ to produce a conflicting transaction tx'. Such block must be equal in all chains by the Persistence property.
\end{proof}


\begin{theorem}
	Under the Honest Majority Assumption, it holds that $\Pi_{PL}$ described in Table \ref{tab:protocolPL} parameterized with $t = \lceil 4\lambda/(1-\epsilon) \rceil$ rounds and $k = \lceil 2\lambda f \rceil$, implements a public transaction ledger with probability at least $1 - e^{-\Omega(\epsilon^2 \lambda f)}$.
\end{theorem}



\subsubsection{Bitcoin Ledger}

In this context protocol parties will be referred to as miners. Transactions and accounts are defined respect to a digital signature scheme. A digital signature scheme is a functionality that allows to reproduce the properties of a physical signature digitally, namely, authentication and non-repudiation. The considered scheme is comprised of tree algorithms $\langle \texttt{KeyGen}, \texttt{Sign}, \texttt{Verify} \rangle$. \texttt{KeyGen} provides a pair $(pk, vk)$ composed by a unique private key and public key, \texttt{Sign} signs any provided message using a provided private key and \texttt{Verify} verifies a given message has been signed by a given account. A signature scheme is \textit{existentially unforgeable} when adversaries can't create signatures that verify for messages they have not already a signature for.

An account is a pair $a = (publicKey, G(publicKey)=adress)$ where $G(\cdot)$ is a hash function and $publicKey$ is also referred to as the account address since it identifies an account in an explicit manner.

A transaction $tx$ is a structure $\{a \rightarrow ((vk, \sigma), \{ (a_1, b_1), \dots , (a_n, b_n) \})$ where $a$ is the account to be debited, $a_1, \dots, a_n$ are the accounts to be credited with funds $b_1, \dots, b_n$ and $(vk, \sigma)$ is a pair of verification key and digital signature for the message $\{a \rightarrow (\{ (a_1, b_1), \dots , (a_n, b_n) \})$. Outgoing balance will be referred to as a transaction output and incoming balance will be referred to as a transaction input.

\texttt{Txgen} oracle has to be specified. It's job will be generating transactions in behalf of honest users.
\begin{itemize}
	\item \texttt{GenAccount}: Calls \texttt{KeyGen} and obtains a pair $(pk, vk)$ then computes $vk$ hash to obtain account $a = (vk, G(vk))$ which is returned. The private key $pk$ is kept in the the state of \texttt{Txgen}.
	\item \texttt{IssueTrans($\hat tx$)}: Returns a transaction $tx$ as long as $\hat tx$ is a transaction that only misses the signature of an account maintained by \texttt{Txgen}.
\end{itemize}

In order to assure the system works correctly it is necessary to impose that each account is only allowed a single transaction, thus, $C(tx_1, tx_2) = 1$ if and only if $tx_1 \neq tx_2$ and $tx_1, tx_2$ have share the input account.
Under this conditions it can be proved that:

\begin{proposition}
	Assume that $\langle Keygen, Sign, Verify \rangle$ is an existentially unforgeable signature scheme. Then oracle \texttt{Txgen} is unambiguous.
\end{proposition}
\begin{proof}
	Since the signature scheme is existentially unforgeable there is no way for adversary to forgery a transaction unless such transaction has already occurred in the past but this cannot happen since $C(\cdot, \cdot)$ doesn't allow more than one transaction from any given account.
\end{proof}

The fact that each account is only able to perform one transaction is not restrictive since one transaction may have more than one output, thus, if a user desires to spend only a fraction of their credit its wallet may create a new account in which the remaining part of their credit can be deposited avoiding any loss.

Transaction validity needs to be determined in order to define the valid ledgers in the Bitcoin environment. A transaction \texttt{tx} is said to be valid if all signatures verify and involved debited accounts balance is greater that the sum of the credited amount, that is, every account $a \in tx$ verifies $\sum_{j=1}^{q}{b_i} \ge \sum_{j=1}^{t}{{b'}_i}$ where $b_i$ is a unique that was previously(including this current transaction) given to $a$ and ${b'}_i$ is a unique output in \texttt{tx}. Calculating PoW means using computational power to calculate a hash function time after time, thus, miners expect to receive a reward for perpetrating such task. Miners receive a reward in the form of a \textit{transaction fee} $= \sum_{j=1}^{q}{c}$ where $c = \sum_{j=1}^{q}{b_i} > \sum_{j=1}^{t}{{b'}_i}$ plus a flat reward $r_m$ which depends on the length of the chain $m$ that it the miner is trying to extend. Transaction fees can be specified as special transactions of the form ``$\varnothing \rightarrow \dots$''. This mechanism allows the spending accounts to grab the miners attention toward its transactions when needed since miners will try to maximize transaction fees. It is important to note that an account is not forced to give all its spare credit as a transaction fee since new accounts can be created at any given time with no added cost.

The initial reward for extending the Bitcoin chain was 50 BTC. The reward progression for Bitcoin follows the geometric progression in Table \ref{tab:progression}.

\begin{centering}
	\begin{table}[]
		\resizebox{\textwidth}{!}{
			\begin{tabular}{c c c c c c}
				\textbf{Date reached} & \textbf{Block} & \textbf{BTC Reward} & \textbf{Year (Estimate)} & \textbf{BTC Added} & \textbf{Stage BTC Added}\\
				1/3/09 & 0 & 50 & 2009 & 2625000 & 12.5\% \\
				4/22/10 & 52500 & 50 & 2010 & 2625000 & 25.00\% \\
				1/28/11 & 105000 & 50 & 2011 & 2625000 & 37.50\% \\
				12/14/11 & 157500 & 50 & 2012 & 2625000 & 50.00\% \\
				11/28/12 & 210000 & 25 & 2013 & 1312500 & 56.25\% \\
				10/9/13 & 262500 & 25 & 2014 & 1312500 & 62.50\% \\
				8/11/14 & 315000 & 25 & 2015 & 1312500 & 68.75\% \\
				7/29/15 & 367500 & 25 & 2016 & 1312500 & 75.00\% \\
				& 420000 & 12.5 & 2017 & 656250 & 78.13\% \\
				& 472500 & 12.5 & 2018 & 656250 & 81.25\% \\
				& 525000 & 12.5 & 2019 & 656250 & 84.38\% \\
				& 577500 & 12.5 & 2020 & 656250 & 87.50\% \\
				& 630000 & 6.25 & 2021 & 328125 & 89.06\% \\
				& 682500 & 6.25 & 2022 & 328125 & 90.63\% \\
				& 735000 & 6.25 & 2023 & 328125 & 92.19\% \\
				& 787500 & 6.25 & 2024 & 328125 & 93.75\% \\
			\end{tabular}
		}
		\caption{Bitcoin Reward Geometric Progression}
		\label{tab:progression}
	\end{table}
\end{centering}


A sequence of transactions $\langle \varnothing \rightarrow \{(a_1, b_1)\}, tx_1, \dots, tx_n \rangle$ is said to be valid with respect to a ledger $l = \langle x_1, \dots, x_m \rangle$ if each transaction is valid with respect to the $l$
extended by transactions previous to it, i.e, for all $j\in \{1, \dots, n\}$ transaction $tx$ has to be valid with respect  to ledger $\langle x_1, \dots, x_m, tx_1, \dots, tx_{j-1} \rangle$.

The set of valid ledgers $\mathcal{L}$ with respect to a reward progression $\{r_j\}_{j \in \N}$ contains any ledger $l$ which extends a ledger in $\mathcal{L}$ by a valid sequence of transactions. The first transaction sequence of any ledger $l \in \mathcal{L}$ contains a single reward transaction $\varnothing \rightarrow \{(a_1, b_1), \dots, (a_n, b_n)\}$ that satisfies $\sum_{j=1}^{n}{b_i} = r_0$, where $r_0$ is the first initial reward. This initial rewards distributes the first coin credit among the ledger's initiator(s). In the case of Bitcoin it was supposedly Nakamoto who collected the first reward.




\section{Byzantine Agreement}

This problem is very close in essence to the entity-fault-tolerant consensus and is traditionally explained with a warlike analogy. Processes as represented as Lieutenants. The Lieutenants's objective is to conquest a fortress. There is a distinguished process, the General. Lieutenants can only communicate through messages. The General will send an order $v$ to each other Lieutenant to attack or retreat. Some Lieutenants may be traitors(including the General) and may exhibit any behavior, i.e byzantine failures\footnotemark. Non-traitor Lieutenants are called loyal.

\begin{definition}[Byzantine Generals Problem]
	A protocol $\Pi$ is said to solve the Byzantine Agreement(BA) problem if it satisfies the following properties:
	\begin{itemize}
		\item \textbf{Agreement}: There is a round after which all honest parties return the same value if queried by the environment.
		\item \textbf{Validity}: The output returned by an honest party $P$ is the input of an honest party $P'$ on round 1.
		\item \textbf{Termination}: Agreement is achieved in a finite time.
	\end{itemize}
	\footnotetext{The name Byzantine failure actually comes from this analogy. The Byzantine Empire is sometimes taken as a reference in political instability due to the plots of intrigue, betrayal and assassination that were said to take place in palace.}
\end{definition}

\begin{remark}
	In the $q$-bounded computational model termination is actually guaranteed.
\end{remark}

The validity condition described in the problem is \textit{strong validity}. \textit{Weak validity} implies that if all parties begin with the same value then the output value has to be that input value. There are no conditions in case more two or more different input values are provided. This is only relevant in case there are more than two possible input values, in which case, the strong validity property implies weak validity and not the other way around. The described protocol has long been known to have solution in a deterministic model if and only if $n > |V|t$ where $V$ is the input. The protocol that solves the problem is called the Oral Messages Protocol:
\begin{lemma}
	The Oral Messages protocol solves the problem for $n>3m$.
\end{lemma}

The following result is also true:
\begin{lemma}
	There is no protocol that satisfies Byzantine Consensus in an asynchronous system with $n$ Liutenants and $m$ traitors with $n<3m$.
\end{lemma}

\begin{theorem}
	The maximum number of failures any protocol can tolerate while achieving Byzantine Consensus is $m = max\{f \in \mathbb{N} : n>3f\}$.
\end{theorem}
Using these two lemmas proven in the famous article \cite{pease1980reaching} the theorem is proven.

\begin{remark}
	Note as stated before the Theorem only holds in a deterministic model. The model described in this work is probabilistic, thus the Theorem cannot be applied on it.
\end{remark}


\subsection{Nakamoto Solution}

This is an interpretation of the solution given by informally by Nakamoto in a mailing list \cite{nakamoto_mail}.
% \todoadd[caption={Historia de la solución}]{Contar que la solución la expuso Nakamoto de forma simplificada en un blog y citarlo. Esta es una interpretación de dicha solución.}

The protocol is very simple. Blocks content is a bit value $x \in \{0, 1\}$. For a chain to be valid the content of all its blocks must be the same. If a party has no local chain it expects one and only one value in its input tape and will attempt to calculate a block with such value. If a party has a local chain it will try to extend it with a block containing the same value as the one present in its chain.

Intuitively, even if there are several times in which two or more parties extend their chain during the same round there will eventually be a uniquely successful round in which only one party will extend its chain. Thus, since Nakamoto supposed an advantage on the PoW achievement of honest parties over the Adversary, Agreement is achieved. While this is true and it will be demonstrated, Validity doesn't seem to be taken in consideration and it will be proved that this protocol doesn't achieve Validity(with high probability). Only environments $\mathcal{Z}$ that provide an initial value to all parties in $P$ are considered.

Formally, external functions are defined as follows.

\begin{centering}
	\begin{table}[H]
	\begin{tabular}{m{0.1\textwidth}<{\centering} m{0.15\textwidth}<{\centering} m{0.665\textwidth}}
		\toprule
		\textbf{Function } & \textbf{Parameters} & \multicolumn{1}{c}{\textbf{Description}}\\
		\toprule
		$V(\cdot)$ & - & $V(\langle x_1,\dots,x_n \rangle)$ is true if and only if $x_1 = \dots x_n \in \{0, 1\}$\\
		\hline
		$R(\cdot)$ & k & If len$(\C) \le k$, $R(\C)$ is the (unique) value that is contained in each block of chain $\C$. Otherwise it is undefined.\\
		\hline
		$I(\cdot)$ & - & If $\C = \epsilon$ the functionality returns the value taken from the input tape INPUT$()$ which is expected to contain (INSERT, $v$). Otherwise the (unique) value present in the $\C$ is returned.\\
		\bottomrule
	\end{tabular}
	\caption{Protocol $\Pi_{\textrm{BA}}^{\textrm{nak}}$}
	\label{tab:protocolNak}
	\end{table}
\end{centering}

First, Agreement well be proved. It follows from the common prefix property. If len$(\C) > k$ then $R(\C)$ will return the value present in the common prefix for every single party.
\begin{lemma}[Agreement]
	Under the Honest Majority Assumption, it holds that protocol $\Pi_{\textrm{BA}}^{\textrm{nak}}$ described in Table \ref{tab:protocolNak} parameterized with $k=\lceil 2f\lambda \rceil$ running for a total number of rounds $L \ge 2k/f$ satisfies Agreement with probability at least $1 - e^{- \Omega(\epsilon^2 f \lambda)}$.
\end{lemma}
\begin{proof}
	By the common prefix property, after $L$ rounds, every honest party will have a chain of length at least k. This is because $\tau L = 2(1 - \epsilon) k > k$ since $\epsilon < \frac{1}{3}$ by the Honest Majority Assumption.
	Since chains contain unique values a disagreement between honest parties chains would imply disjoint chains which contradict the common prefix property considering all chains have more than $k$ blocks.
\end{proof}
Note that the inequality can be further fit by taking $L \ge 1.5k/f$.

Regarding Validity; Unless the adversary PoW success rate is negligible compared to the honest players, Validity cannot be guaranteed with overwhelming probability. This is because if the adversary finds a solution faster than the honest parties it will broadcast it and every party will attempt to extend a chain with a value that is not guaranteed to be among the initial ones for any honest party. Hence, it can be formally proved that Validity can only be assured with $(n-t)/n$ probability, which is the rate of honest parties running the protocol.



\subsection{Alternative Solution}

An alternative solution will be given using the backbone protocol that, under an strengthened version of Honest Majority, can assure Agreement and Validity as long as the adversary's hashing power is bounded by $\frac{1}{3}$. The protocol is based on $\Pi_{BA}^{nak}$ with two major differences. First, parties always try to add their input value to the current chain they are attempting to extend. Second, chains no longer contain unique values, after round $L$ they output the majority of their local length $k$ prefix. For the second condition to be correctly defined binary BA is considered. Just as before, the only environments $\mathcal{Z}$ considered are the ones that provide an initial value to all parties in $P$.

Formally, the protocol is defined as follows:

\begin{centering}
	\begin{table}[H]
	\begin{tabular}{m{0.1\textwidth}<{\centering} m{0.15\textwidth}<{\centering} m{0.665\textwidth}}
		\toprule
		\textbf{Function } & \textbf{Parameters} & \multicolumn{1}{c}{\textbf{Description}}\\
		\toprule
		$V(\cdot)$ & - & $V(\langle x_1, \dots, x_n \rangle)$ is true if and only if $v_1, \dots, v_n \in \{0, 1\}$.\\
		\hline
		$R(\cdot)$ & k & If len$(\C) > 2k$, $R(\C)$ returns the majority bit of $v_1, \dots, v_k$. Otherwise it is undefined.\\
		\hline
		$I(\cdot)$ & - & $I(\dot)$ always returns $v$ which the value taken from input tape INPUT() which is expected to contain (INSERT, $v$).\\
		\bottomrule
	\end{tabular}
	\caption{Protocol $\Pi_{\textrm{BA}}^{\textrm{alt}}$}
	\label{tab:protocolAlt}
	\end{table}
\end{centering}

\begin{lemma}[Agreement]
	Under the Honest Majority Assumption, it holds that $\Pi_{BA}^{alt}$ defined in Table \ref{tab:protocolAlt} parameterized with $k=\lceil 2f\lambda \rceil$ running for a total number of rounds $L \ge 4k/f$, satisfies Agreement with probability at least $1 - e^{-\Omega(\epsilon^2 f \lambda)}$.
\end{lemma}
\begin{proof}
	As stated in the protocol description, each party is constantly trying to include its input value into the chain and this means chains no longer have to contain unique values. Since the reading function $(\cdot)$ returns the majority bit of the first $k$ blocks, in order to provide Agreement it is enough with assuring the same first $k$ blocks of each chain are equal. By the chain growth property $\tau L = 4 (1-\epsilon)k > 2k$, since $\epsilon < \frac{1}{3}$. A disagreement in the first $k$ blocks of two given chains $\C_1, \C_2$ implies $\C_1^{\lceil k} \npreceq \C_2$ and $\C_2^{\lceil k} \npreceq \C_1$ which contradicts the common prefix property.
\end{proof}
Just as before, note that the inequality can be further fit by taking $L \ge 1.5k/f$.


\begin{lemma}[Validity]
	Under the Honest Majority Assumption strengthened so that $\frac{t}{n-t} \le \frac{1-\delta}{2}$, it holds that $\Pi_{BA}^{alt}$ defined in Table \ref{tab:protocolAlt} parameterized with $k=\lceil 2f\lambda \rceil$ running for a total number of rounds $L \ge 4k/f$, satisfies Agreement with probability at least $1 - e^{-\Omega(\epsilon^2 f \lambda)}$.
\end{lemma}
\begin{proof}
	It is enough to prove that the majority of the bits of the first $k$ blocks of any chain contain a value present in one of the honest parties input tape. This can be proved showing that most of the first $k$ blocks were mined by honest parties. Assuming a typical execution, since $k > 2f\lambda$, Theorem \ref{theorem:cq} can be applied and thee rate of honest blocks in any set of $k$(or more) consecutive blocks contains at least $\mu > \frac{1}{2} + \frac{1-\delta}{2} - (1+\frac{\delta}{2}) \cdot \frac{t}{n-t} > \frac{1}{2} + \frac{t}{n-t} - (1+\frac{\delta}{2}) \cdot \frac{t}{n-t} > \frac{1}{2} + \frac{t}{n-t} - \frac{t}{n-t} = \frac{1}{2}$ honest blocks.
\end{proof}

It is easy to see that the strengthened Honest Majority Assumption implies that the adversary's hashing power is bounded by $1/3$. Thus, the following theorem has been proven:
\begin{theorem}
	Under the Honest Majority Assumption strengthened so that $\frac{t}{n-t} \le \frac{1-\delta}{2}$, it holds that $\Pi_{BA}^{alt}$ defined in Table \ref{tab:protocolAlt} parameterized with $k=\lceil 2f\lambda \rceil$ running for a total number of rounds $L \ge 4k/f$, solves the Byzantine Generals problem with probability at least $1 - e^{-\Omega(\epsilon^2 f \lambda)}$.
\end{theorem}
% \todoexplain[caption={Casuística para un mayor tamaño de entrada}]{Mencionar que pasa cuando el número de valores posibles es mayor que 2: Pag. 29, Remark 6}




\end{document}
